{"meta":{"title":"XiaoFu's Blog","subtitle":"","description":"Blog","author":"Xiao","url":"https://xiaochuanfu.github.io","root":"/"},"pages":[{"title":"","date":"2022-10-30T10:04:34.412Z","updated":"2022-10-30T10:04:34.412Z","comments":true,"path":"404.html","permalink":"https://xiaochuanfu.github.io/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2022-10-30T09:48:12.040Z","updated":"2022-10-30T09:48:12.040Z","comments":true,"path":"about/index.html","permalink":"https://xiaochuanfu.github.io/about/index.html","excerpt":"","text":"你好，我是萧萧！！！"},{"title":"友情链接","date":"2022-05-19T16:00:00.000Z","updated":"2022-10-30T09:55:29.561Z","comments":true,"path":"friends/index.html","permalink":"https://xiaochuanfu.github.io/friends/index.html","excerpt":"以后的路还长，要加油哦！","text":"以后的路还长，要加油哦！ 可以在评论中留下友链。"},{"title":"","date":"2022-03-11T07:29:26.379Z","updated":"2022-03-11T07:29:26.379Z","comments":true,"path":"mylist/index.html","permalink":"https://xiaochuanfu.github.io/mylist/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2022-03-11T07:28:16.380Z","updated":"2022-03-11T07:28:16.380Z","comments":true,"path":"categories/index.html","permalink":"https://xiaochuanfu.github.io/categories/index.html","excerpt":"","text":""},{"title":"Page","date":"2013-12-26T14:52:56.000Z","updated":"2022-03-11T07:30:29.167Z","comments":true,"path":"page/index.html","permalink":"https://xiaochuanfu.github.io/page/index.html","excerpt":"","text":"This is a page test."},{"title":"所有标签","date":"2022-03-11T07:28:34.219Z","updated":"2022-03-11T07:28:34.219Z","comments":true,"path":"tags/index.html","permalink":"https://xiaochuanfu.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2022-11-02T15:02:32.896Z","updated":"2022-11-02T15:02:32.896Z","comments":true,"path":"media/org.volantis/README.html","permalink":"https://xiaochuanfu.github.io/media/org.volantis/README.html","excerpt":"","text":"cdn-org 获取路径： https://www.jsdelivr.com/package/gh/volantis-x/cdn-org 也可以直接拼接路径： https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/文件 例如： https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/Logo-Cover@3x.png"},{"title":"","date":"2022-11-02T15:02:32.896Z","updated":"2022-11-02T15:02:32.896Z","comments":true,"path":"media/placeholder/README.html","permalink":"https://xiaochuanfu.github.io/media/placeholder/README.html","excerpt":"","text":"CDN获取路径： https://www.jsdelivr.com/package/gh/cdn-x/placeholder 文件路径： https://cdn.jsdelivr.net/gh/cdn-x/placeholder/README.md"},{"title":"","date":"2022-11-02T15:02:32.888Z","updated":"2022-11-02T15:02:32.888Z","comments":true,"path":"media/fonts/CascadiaCode/README.html","permalink":"https://xiaochuanfu.github.io/media/fonts/CascadiaCode/README.html","excerpt":"","text":"Microsoft 去年出的一款好看的编程等宽字体GitHub源码 体验的效果可见我的博客 它对代码中的某些运算符的显示做了优化, 如&lt;=自动变成了≤, 但复制下来还是&lt;= . 当然你也可以选择不要这个连字优化, 那就用带PL的字体"},{"title":"","date":"2022-11-02T15:02:32.888Z","updated":"2022-11-02T15:02:32.888Z","comments":true,"path":"media/twemoji/README.html","permalink":"https://xiaochuanfu.github.io/media/twemoji/README.html","excerpt":"","text":"Twitter Emoji (Twemoji) A simple library that provides standard Unicode emoji support across all platforms. Twemoji v12.0 adheres to the Unicode 12.0 spec and supports the Emoji 12.0 spec The Twemoji library offers support for 3,075 emojis. UsageCDN SupportThe folks over at MaxCDN have graciously provided CDN support. Use the following in the &lt;head&gt; tag of your HTML document(s): &lt;script src=&quot;https://twemoji.maxcdn.com/v/latest/twemoji.min.js&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt; This guarantees that you will always use the latest version of the library. If, instead, you’d like to include the latest version explicitly, you can add the following tag: &lt;script src=&quot;https://twemoji.maxcdn.com/v/12.1.6/twemoji.min.js&quot; integrity=&quot;sha384-XfulzVp257jTD4j8TtghtZ75YaRE+O+F2brm/dAHuawJEvzeoco+4c0Q1bm5ha3M&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt; DownloadIf instead you want to download a specific version, please look at the gh-pages branch, where you will find the built assets for both our latest and older versions. APIFollowing are all the methods exposed in the twemoji namespace. twemoji.parse( … ) V1This is the main parsing utility and has 3 overloads per parsing type. There are mainly two kinds of parsing: string parsing and DOM parsing. Each of them accepts a callback to generate an image source or an options object with parsing info. Here is a walkthrough of all parsing possibilities: DOM parsingIn contrast to string parsing, if the first argument is an HTMLElement, generated image tags will replace emoji that are inside #text nodes only without compromising surrounding nodes or listeners, and completely avoiding the usage of innerHTML. If security is a major concern, this parsing can be considered the safest option but with a slight performance penalty due to DOM operations that are inevitably costly. var div = document.createElement(&#39;div&#39;); div.textContent = &#39;I \\u2764\\uFE0F emoji!&#39;; document.body.appendChild(div); twemoji.parse(document.body); var img = div.querySelector(&#39;img&#39;); // note the div is preserved img.parentNode === div; // true img.src; // https://twemoji.maxcdn.com/v/latest/72x72/2764.png img.alt; // \\u2764\\uFE0F img.className; // emoji img.draggable; // false All other overloads described for string are available in exactly the same way for DOM parsing. Object as parameterHere’s the list of properties accepted by the optional object that can be passed to the parse function. &#123; callback: Function, // default the common replacer attributes: Function, // default returns &#123;&#125; base: string, // default MaxCDN ext: string, // default &quot;.png&quot; className: string, // default &quot;emoji&quot; size: string|number, // default &quot;72x72&quot; folder: string // in case it&#39;s specified // it replaces .size info, if any &#125; callbackThe function to invoke in order to generate image src(s). By default it is a function like the following one: function imageSourceGenerator(icon, options) &#123; return &#39;&#39;.concat( options.base, // by default Twitter Inc. CDN options.size, // by default &quot;72x72&quot; string &#39;/&#39;, icon, // the found emoji as code point options.ext // by default &quot;.png&quot; ); &#125; baseThe default url is the same as twemoji.base, so if you modify the former, it will reflect as default for all parsed strings or nodes. extThe default image extension is the same as twemoji.ext which is &quot;.png&quot;. If you modify the former, it will reflect as default for all parsed strings or nodes. classNameThe default class for each generated image is emoji. It is possible to specify a different one through this property. sizeThe default asset size is the same as twemoji.size which is &quot;72x72&quot;. If you modify the former, it will reflect as default for all parsed strings or nodes. folderIn case you don’t want to specify a size for the image. It is possible to choose a folder, as in the case of SVG emoji. twemoji.parse(genericNode, &#123; folder: &#39;svg&#39;, ext: &#39;.svg&#39; &#125;); This will generate urls such https://twemoji.maxcdn.com/svg/2764.svg instead of using a specific size based image. UtilitiesBasic utilities &#x2F; helpers to convert code points to JavaScript surrogates and vice versa. twemoji.convert.fromCodePoint()For a given HEX codepoint, returns UTF-16 surrogate pairs. twemoji.convert.fromCodePoint(&#39;1f1e8&#39;); // &quot;\\ud83c\\udde8&quot; twemoji.convert.toCodePoint()For given UTF-16 surrogate pairs, returns the equivalent HEX codepoint. twemoji.convert.toCodePoint(&#39;\\ud83c\\udde8\\ud83c\\uddf3&#39;); // &quot;1f1e8-1f1f3&quot; twemoji.convert.toCodePoint(&#39;\\ud83c\\udde8\\ud83c\\uddf3&#39;, &#39;~&#39;); // &quot;1f1e8~1f1f3&quot; TipsInline StylesIf you’d like to size the emoji according to the surrounding text, you can add the following CSS to your stylesheet: img.emoji &#123; height: 1em; width: 1em; margin: 0 .05em 0 .1em; vertical-align: -0.1em; &#125; This will make sure emoji derive their width and height from the font-size of the text they’re shown with. It also adds just a little bit of space before and after each emoji, and pulls them upwards a little bit for better optical alignment. UTF-8 Character SetTo properly support emoji, the document character set must be set to UTF-8. This can done by including the following meta tag in the document &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; Exclude Characters (V1)To exclude certain characters from being replaced by twemoji.js, call twemoji.parse() with a callback, returning false for the specific unicode icon. For example: twemoji.parse(document.body, &#123; callback: function(icon, options, variant) &#123; switch ( icon ) &#123; case &#39;a9&#39;: // © copyright case &#39;ae&#39;: // ® registered trademark case &#39;2122&#39;: // ™ trademark return false; &#125; return &#39;&#39;.concat(options.base, options.size, &#39;/&#39;, icon, options.ext); &#125; &#125;); Legacy API (V1)If you’re still using our V1 API, you can read our legacy documentation here. ContributingThe contributing documentation can be found here. Attribution RequirementsAs an open source project, attribution is critical from a legal, practical and motivational perspective in our opinion. The graphics are licensed under the CC-BY 4.0 which has a pretty good guide on best practices for attribution. However, we consider the guide a bit onerous and as a project, will accept a mention in a project README or an ‘About’ section or footer on a website. In mobile applications, a common place would be in the Settings&#x2F;About section (for example, see the mobile Twitter application Settings-&gt;About-&gt;Legal section). We would consider a mention in the HTML&#x2F;JS source sufficient also. Community Projects Twemoji Amazing by @SebastianAigner: Use Twemoji using CSS classes (like Font Awesome). Twemoji Ruby by @JollyGoodCode: Use Twemoji in Ruby. Twemoji for Pencil by @Nathanielnw: Use Twemoji in Pencil. FrwTwemoji - Twemoji in dotnet by @FrenchW: Use Twemoji in any dotnet project (C#, asp.net …). Emojiawesome - Twemoji for Yellow by @datenstrom: Use Twemoji on your website. EmojiPanel for Twitter by @danielbovey: Insert Twemoji into your tweets on twitter.com. Twitter Color Emoji font by @bderickson: Use Twemoji as your system default font on Linux &amp; OS X. Emojica by @xoudini: An iOS framework allowing you to replace all standard emoji in strings with Twemoji. [Unmaintained] Twemoji Awesome by @ellekasai: Use Twemoji using CSS classes (like Font Awesome). Committers and Contributors Bryan Haggerty (Twitter) Nathan Downs (Twitter) Tom Wuttke (ex-Twitter) Andrea Giammarchi (ex-Twitter) Joen Asmussen (WordPress) Marcus Kazmierczak (WordPress) The goal of this project is to simply provide emoji for everyone. We definitely welcome improvements and fixes, but we may not merge every pull request suggested by the community due to the simple nature of the project. The rules for contributing are available in the CONTRIBUTING.md file. Thank you to all of our contributors. LicenseCopyright 2019 Twitter, Inc and other contributors Code licensed under the MIT License: http://opensource.org/licenses/MIT Graphics licensed under CC-BY 4.0: https://creativecommons.org/licenses/by/4.0/"}],"posts":[{"title":"个人服务器上搭建图床","slug":"个人服务器上搭建图床","date":"2022-11-05T14:05:00.000Z","updated":"2022-11-05T14:20:22.377Z","comments":true,"path":"2022/11/05/个人服务器上搭建图床/","link":"","permalink":"https://xiaochuanfu.github.io/2022/11/05/%E4%B8%AA%E4%BA%BA%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/","excerpt":"","text":"PicGo SFTP 上传插件文档：https://github.com/imba97/picgo-plugin-sftp-uploader 1、PicGo上下载sftp插件 2、根据文档设置 12345678910111213sftpUploader.json&#123; &quot;Xiaobolg&quot;: &#123; &quot;url&quot;: &quot;http://124.222.18.192&quot;, &quot;path&quot;: &quot;/BlogImage/&#123;year&#125;/&#123;month&#125;/&#123;fullName&#125;&quot;, &quot;uploadPath&quot;: &quot;/www/WordPress/BlogImage/&#123;year&#125;/&#123;month&#125;/&#123;fullName&#125;&quot;, &quot;host&quot;: &quot;124.222.18.192&quot;, &quot;port&quot;: &quot;22&quot;, &quot;username&quot;: &quot;root&quot;, &quot;password&quot;: &quot;xiaochuanfu1221.&quot; &#125;&#125; 3.上传图片 ​ 在typora中引入这个图片链接，图片便可以成功显示。 ​","categories":[],"tags":[{"name":"图床","slug":"图床","permalink":"https://xiaochuanfu.github.io/tags/%E5%9B%BE%E5%BA%8A/"}]},{"title":"Python基础","slug":"Python基础","date":"2022-11-05T13:49:53.000Z","updated":"2022-11-05T13:52:16.100Z","comments":true,"path":"2022/11/05/Python基础/","link":"","permalink":"https://xiaochuanfu.github.io/2022/11/05/Python%E5%9F%BA%E7%A1%80/","excerpt":"","text":"第一节, 爬虫入门+python基础内容回顾.一. 关于爬虫的特殊性爬虫是一个很蛋疼的东西, 可能今天讲解的案例. 明天就失效了. 所以, 不要死盯着一个网站干. 要学会**见招拆招**(爬虫的灵魂) 爬虫程序如果编写的不够完善. 访问频率过高. 很有可能会对服务器造成毁灭性打击, 所以, 不要死盯着一个网站干. 请放慢你爬取的速度. 为你好, 也为网站好. 腾讯, 阿里, 字节的网站, 反爬手段很残忍. 新手不要去挑战这种大厂. 等你有实力了. 慢慢研究(哪个都要研究很久….)gov的网站, 非必要, 不爬取. 非要爬取. 请一定降低访问频率. 为你好…. 不要以为gov的网站好欺负. 那是地方性的网站. 中央的很多重要网站都有非常强力的防护措施(瑞数等…) 这种. 愿意搞的. 自己研究. 樵夫搞不定…. 网站的多变性: 这个是爬虫的魅力. 我们要全方位的去思考. 就像找漏洞一样. 思维逻辑不可能是固定的. 达到目的即可. 不要死磕牛角尖. 要不然, 你会死的很惨…. 二. 必须要掌握的py基础2.1 基础语法相关 if条件判断 1234567if 条件: # 事情1else: # 事情2 当你需要判断的时候. 就去写if. 上面就是if的最基础的语法规则. 含义是, 如果条件为真, 去执行事情1, 如果条件不真, 去执行事情2. 这东西. 我就不拆开聊了. 关于if. 你要记住的事情是, 它是用来做条件判断的. 以后你的程序里, 如果需要条件判断了. 就用它…. 举例, 在写爬虫的时候. 我们会遇到这样的两种情况 情况一, 数据里有一些我们并不需要的内容 123456789data = &quot;10,英雄本色,1500万&quot; # 正常你需要的数据data = &quot;11,-,-&quot; # 你不需要的数据# 伪代码, 理解含义(思路)if data里有你需要的数据: 处理数据else: 再见 baidu.com 第一页的内容和第二页的内容 网页有可能会有多种页面结构 小伙伴1. 逼着自己写一个提取器。 去适应不同的页面结构 -&gt; 难度系数(非常高) 小伙伴2. 写两个提取器, 不同的提取器去爬取不同的网页 情况二, 页面结构不统一, 会有两种页面结构 1234567891011# 伪代码, 理解含义(思路)提取器1 = xxxx # 用来提取页面中内容的提取器2 = xxxxxx# 页面有可能是不规则的。 结果1 = 提取器1.提取(页面)if 结果1: 有结果. 存起来else: 没有结果. 结果2 = 提取器2.提取(页面) 相信我, 上面的逻辑并不难. 但是, 到了后面很多小伙伴容易踩坑. 我们完全没必要用一个提取器获取所有的数据. 完全没必要….. while循环关于循环, 我们必须要知道一个事情. 12while 条件: 循环体 如果条件为真, 就执行循环体, 然后再次判断条件…..直到条件为假. 结束循环. 反复的执行一段代码 关于True和False True, 是真的意思. 翻译成人话: 对的, OK, 没毛病. 确定 False, 是假的意思. 翻译成人话: 不对劲, 错误, No. 有瑕疵. 不对劲 这个应该都能看懂. 但是下面这个, 需要各位去记住 12345678910111213141516# 几乎所有能表示为空的东西. 都可以认为是Falseprint(bool(0))print(bool(&quot;&quot;))print(bool([]))print(bool(&#123;&#125;))print(bool(set()))print(bool(tuple()))print(bool(None))# 上面这一坨全是False, 相反的. 都是真. 利用这个特性. 我们可以有以下的一些写法# 伪代码, 理解逻辑. 结果 = 提取器.提取(页面)if 结果: 有结果. 我要保存结果else: 没结果....... 2.2 字符串字符串在`爬虫`里. 必须要知道的几个操作: 索引和切片索引, 就是第几个字符. 它从0开始.切片, 从字符串中提取n个字符. 12345s = &quot;我爱黎明,黎明爱我&quot;print(s[1])print(s[0])print(s[2:4]) 从第2个, 到第4个(取不到4) strip() 我们从网页上提取的数据. 很多都是带有一些杂质的(换行, 空格),怎么去掉? strip()可以去掉字符串左右两端的空白(空格, 换行\\n, 回车\\r, 制表符\\t) 123s = &quot; \\t\\t\\t我的天哪\\r\\r \\n\\n &quot; # 够乱的字符串s1 = s.strip()print(s1) # 好了 `我的天哪` split() split, 做切割的. 123456789s = &quot;10,男人本色,100000万&quot; # 你在网页上提取到这样的一段数据. 现在我需要电影名称tmps = s.split(&quot;,&quot;)name = tmps[1]print(name) # 男人本色id, name, money = s.split(&quot;,&quot;) # 切割后. 把三个结果直接怼给三个变量print(id)print(name)print(money) replace() replace, 字符串替换 123s = &quot;我 \\t\\t\\n\\n爱 黎 明 &quot; # 这是你从网页上拿到的东西s1 = replace(&quot; &quot;, &quot;&quot;).replace(&quot;\\t&quot;, &quot;&quot;).replace(&quot;\\n&quot;, &quot;&quot;) # 干掉空格, \\t, \\nprint(s1) # 我爱黎明 join() join, 将列表拼接为一个完整的字符串 12345678lst = [&quot;我妈&quot;, &quot;不喜欢&quot;, &quot;黎明&quot;] # 有时,由于网页结构的不规则, 导致获取的数据是这样的. s1 = &quot;&quot;.join(lst) # 用空字符串把lst中的每一项拼接起来print(s1) # 我妈不喜欢黎明lst2 = [&quot;\\n\\r&quot;,&quot;\\n\\r&quot;,&quot;周杰伦\\n\\r&quot;, &quot;\\n不认识我\\r&quot;] s2 = &quot;&quot;.join(lst2).replace(&quot;\\n&quot;, &quot;&quot;).replace(&quot;\\r&quot;, &quot;&quot;)print(s2) # 周杰伦不认识我 f-string 格式化字符串的一种方案 12345678910s = &quot;周杰伦&quot;s1 = f&quot;我喜欢&#123;s&#125;&quot; # 它会把一个变量塞入一个字符串print(s1) # 我喜欢周杰伦k = 10085s2 = f&quot;我的电话号是&#123;k+1&#125;&quot; # 它会把计算结果赛入一个字符串print(s2) # 我的电话号是10086# 综上, f-string的大括号里, 其实是一段表达式.能计算出结果即可 2.3 列表列表, 我们未来遇见的仅次于字符串的一种数据类型. 它主要是能承载大量的数据. 理论上. 你的内存不炸. 它就能一直存 索引, 切片 列表的索引和切片逻辑与字符串完全一致 123456789101112131415lst = [&quot;赵本山&quot;, &quot;王大陆&quot;, &quot;大嘴猴&quot;, &quot;马后炮&quot;]item1 = lst[2] # 大嘴猴item2 = lst[1] # 王大陆lst2 = lst[2:]print(lst2) # [&quot;大嘴猴&quot;, &quot;马后炮&quot;]# 注意, 如果列表中没有数据. 取0会报错lst = []print(lst[0]) # 报错, Index out of bounds# 注意, 如果给出的索引下标超过了列表的最大索引. 依然会报错lst = [&quot;123&quot;, &quot;456&quot;]print(lst[9999]) # 报错, Index out of bounds 增加 给列表添加数据. append 1234lst = [11,22]lst.append(33)lst.append(44)print(lst) # [11,22,33,44] 删除 删除数据(不常用, 好不容易爬到的数据. 为什么要删) 1lst.remove(&quot;周润发&quot;) # 把周润发删掉 修改 123lst = [&quot;赵本山&quot;, &quot;王大陆&quot;, &quot;大嘴猴&quot;, &quot;马后炮&quot;]lst[1] = &quot;周杰伦&quot;print(lst) # [&quot;赵本山&quot;, &quot;周杰伦&quot;, &quot;大嘴猴&quot;, &quot;马后炮&quot;] range 用for循环数数的一个东西 12345for i in range(10): print(i) # 从0数到9 for i in range(5, 10): print(i) # 从5 数到 9 查询(必会!!!!) 123456789101112lst = [&quot;赵本山&quot;, &quot;周杰伦&quot;, &quot;大嘴猴&quot;, &quot;马后炮&quot;]print(lst[0])print(lst[1])print(lst[2])print(lst[3])# 循环列表的索引for i in range(len(lst)): print(lst[i])# 循环列表的内容for item in lst: print(item) 2.4 字典字典可以成对儿的保存数据. 增加 123456dic = &#123;&#125;dic[&#x27;name&#x27;] = &#x27;樵夫&#x27;dic[&#x27;age&#x27;] = 18print(dic) # &#123;&quot;name&quot;: &quot;樵夫&quot;, &quot;age&quot;: 18&#125; 修改 123dic = &#123;&quot;name&quot;: &quot;樵夫&quot;, &quot;age&quot;: 18&#125;dic[&#x27;age&#x27;] = 19print(dic) # &#123;&quot;name&quot;: &quot;樵夫&quot;, &quot;age&quot;: 19&#125; 删除(不常用) 123dic = &#123;&quot;name&quot;: &quot;樵夫&quot;, &quot;age&quot;: 18&#125;dic.pop(&quot;age&quot;)print(dic) # &#123;&#x27;name&#x27;: &#x27;樵夫&#x27;&#125; 查询(重点) 1234567891011dic = &#123;&quot;name&quot;: &quot;樵夫&quot;, &quot;age&quot;: 18&#125;a = dic[&#x27;name&#x27;] # 查询&#x27;name&#x27;的值print(a) # 樵夫b = dic[&#x27;age&#x27;] # 拿到dic中age对应的值print(b) # 18c = dic[&#x27;哈拉少&#x27;] # 没有哈拉少. 报错d = dic.get(&quot;哈拉少&quot;) # 没有哈拉少, 不报错. 返回None. 它好. 它不报错 循环 12345dic = &#123;&quot;name&quot;: &quot;樵夫&quot;, &quot;age&quot;: 18&#125;for k in dic: # 循环出所有的key print(k) print(dic[k]) # 获取到所有的value并打印 嵌套 1234567891011121314151617181920dic = &#123; &quot;name&quot;: &quot;王峰&quot;, &quot;age&quot;: 18, &quot;wife&quot;: &#123; &quot;name&quot;: &quot;章子怡&quot;, &quot;age&quot;: 19, &#125;, &quot;children&quot;: [ &#123;&#x27;name&#x27;:&quot;胡一菲&quot;, &quot;age&quot;: 19&#125;, &#123;&#x27;name&#x27;:&quot;胡二菲&quot;, &quot;age&quot;: 18&#125;, &#123;&#x27;name&#x27;:&quot;胡三菲&quot;, &quot;age&quot;: 17&#125;, ]&#125;# 王峰的第二个孩子的名字print(dic[&#x27;children&#x27;][1][&#x27;name&#x27;])# 王峰所有孩子的名称和年龄for item in dic[&#x27;children&#x27;]: print(item[&#x27;name&#x27;]) print(item[&#x27;age&#x27;]) 2.5 字符集和bytes字符集, 记住两个字符集就够了. 一个是utf-8, 一个是gbk. 都是支持中文的. 但是utf-8的编码数量远大于gbk. 我们平时使用的最多的是utf-8 12345678910# 把字符串转化成字节bs = &quot;我的天哪abcdef&quot;.encode(&quot;utf-8&quot;)print(bs) # b&#x27;\\xe6\\x88\\x91\\xe7\\x9a\\x84\\xe5\\xa4\\xa9\\xe5\\x93\\xaaabcdef&#x27;# 一个中文在utf-8里是3个字节. 一个英文是一个字节. 所以英文字母是正常显示的# 把字节还原回字符串bs = b&#x27;\\xe6\\x88\\x91\\xe7\\x9a\\x84\\xe5\\xa4\\xa9\\xe5\\x93\\xaaabcdef&#x27;s = bs.decode(&quot;utf-8&quot;)print(s) 记住, bytes不是给人看的. 是给机器看的. 我们遇到的所有文字, 图片, 音频, 视频. 所有所有的东西到了计算机里都是字节. 2.6 文件操作python中. 想要处理一个文件. 必须用open()先打开一个文件 语法规则 123f = open(文件名, mode=&quot;模式&quot;, encoding=&#x27;文件编码&#x27;)f.read()|f.write()f.close() 文件名就不解释了. 模式: 我们需要知道的主要有4个. 分别是: r, w, a, b r 只读模式. 含义是, 当前这一次open的目的是读取数据. 所以, 只能读. 不能写 w 只写模式. 含义是, 当前这一次open的目的是写入数据. 所以, 只能写, 不能读 a 追加模式. 含义是, 当前这一次open的目的是向后追加. 所以, 只能写, 不能读 b 字节模式. 可以和上面三种模式进行混合搭配. 目的是. 写入的内容或读取的内容是字节. 问: 如果我想保存一张图片. 应该用哪种模式? 我想读取txt文件, 用哪种模式? 我想复制一个文件. 应该用哪种模式? encoding: 文件编码. 只有处理的文件是文本的时候才能使用. 并且mode不可以是b. 99%的时候我们用的是utf-8 另一种写法: 12with open(文件名, mode=模式, encoding=编码) as f: pass 这种写法的好处是, 不需要我们手动去关闭f 读取一个文本文件: 123with open(&quot;躺尸一摆手.txt&quot;, mode=&quot;r&quot;, encoding=&quot;utf-8&quot;) as f: for line in f: # for循环可以逐行的进行循环文件中的内容 print(line) 2.7 关于函数在代码量很少的时候, 我们并不需要函数. 但是一旦代码量大了. 一次写个几百行代码. 调试起来就很困难. 此时, 建议把程序改写成一个一个具有特定功能的函数. 方便调试. 也方便代码的重用 123def 函数名(形式参数): # 函数体 return 返回值 上面是编写一个函数的固定逻辑. 但是, 编写好的函数是不会自己运行的. 必须有人调用才可以 1函数名(实际参数) 写一个试试: 123456def get_page_source(url): print(&quot;我要发送请求了. 我要获取到页面源代码啊&quot;) return &quot;页面源代码&quot;pg_one = get_page_source(&quot;baidu.com&quot;)pg_two = get_page_source(&quot;koukou.com&quot;) 再来一个 123456def download_image(url, save_path): print(f&quot;我要下载图片&#123;url&#125;了&quot;, f&quot;保存在&#123;save_path&#125;&quot;)donwload_image(&quot;http://www.baidu.com/abc/huyifei.jpg&quot;, &quot;胡二飞.jpg&quot;)donwload_image(&quot;http://www.baidu.com/aaa/dagedagefeifeifei.jpg&quot;, &quot;大哥大哥飞飞飞.jpg&quot;) 总结, 函数的好处就是, 以后需要该功能. 不用再写重复代码了. 2.8 关于模块模块是啥? 模块就是已经有人帮我们写好了的一些代码, 这些代码被保存在一个py文件或者一个文件夹里. 我们可以拿来直接用 在python中有三种模块. 第一种, python内置模块 不用安装. 直接导入就能用 第二种, 第三方模块 需要安装. 安装后. 导入就可以用了 第三种, 自定义模块(新手先别自己定义模块) 直接导入就能用 导入模块的语法 123456789import 模块from 模块 import 功能from 模块.子模块 import 功能举例子, import osimport sysfrom urllib.parse import urljoinfrom bs4 import BeautifulSoup 搞爬虫.必须要了解的一些python内置模块 time模块 123import timetime.time() # 这个是获取到时间戳time.sleep(999) # 让程序暂停999秒 os模块 12345import os# 判断文件是否存在os.path.exists() # 判断文件或者文件夹是否存在os.path.join() # 路径拼接os.makedirs() # 创建文件夹 json模块(重中之重) 现在的网站不同于从前了. 习惯性用json来传递数据. 所以, 我们必须要知道json是啥, 以及python如何处理json. json是一种类似字典一样的东西. 对于python而言, json是字符串. 例如, 1s = &#x27;&#123;&quot;name&quot;: &quot;jay&quot;, &quot;age&quot;: 18&#125;&#x27; 你看. 这破玩意就是json 如何来转化它. json字符串 &#x3D;&gt; python字典 1234import jsons = &#x27;&#123;&quot;name&quot;: &quot;jay&quot;, &quot;age&quot;: 18&#125;&#x27;dic = json.loads(s)print(type(dic)) python字典 &#x3D;&gt; json字符串 1234import jsondic = &#123;&quot;name&quot;: &quot;jay&quot;, &quot;age&quot;: 18&#125;s = json.dumps(dic)print(type(s)) random模块 随机. 没别的用处.生成随机数 123import randomi = random.randint(1, 10) # 1~10的随机数print(i) # 多跑两次.效果更加 异常处理 这个是重点. 我们在写爬虫的时候. 非常容易遇到问题. 但这些问题本身并不是我们程序的问题. 比如, 你在抓取某网站的时候. 由于网络波动或者他服务器本身压力太大. 导致本次请求失败. 这种现象太常见了. 此时, 我们程序这边就会崩溃. 打印一堆红色的文字. 让你难受的一P. 怎么办? 我们要清楚一个事情. 我们平时在打开一个网址的时候. 如果长时间没有反应, 或者加载很慢的时候. 我们习惯性的会刷新网页. 对吧. 这个逻辑就像: 程序如果本次请求失败了. 能不能重新来一次. OK, 我们接下来聊的这个异常处理. 就是干这个事儿的. 12345678try: # 尝试... print(&quot;假如, 我是一段爬虫代码, 请求到对方服务器&quot;) print(&quot;我得出事儿啊&quot;) print(1/0) # 出事儿了except Exception as e: # 出错了. 我给你兜着 print(e) # 怎么兜? 打印一下. 就过去了 print(&quot;不论上面是否出错. 我这里, 依然可以执行&quot;) 看懂了么? 程序执行的时候. 如果try中的代码出现错误. 则自动跳到except中. 并执行except中的代码. 然后程序正常的, 继续执行 有了这玩意. 我们就可以写出一段很漂亮的代码逻辑: 12345678910while 1: try: 我要发送请求了. 我要干美国CIA的总部. 我要上天 print(&quot;我成功了!!&quot;) break # 成功了.就跳出循环 except Exception as e: print(&quot;失败了&quot;) print(&quot;我不怕失败&quot;) print(&quot;再来&quot;) 改良版: 123456789101112import timefor i in range(10): try: 我要发送请求了. 我要干美国CIA的总部. 我要上天 print(&quot;我成功了!!&quot;) break # 成功了.就跳出循环 except Exception as e: print(&quot;失败了&quot;) print(&quot;我不怕失败&quot;) print(&quot;再来&quot;) time.sleep(i * 10) 在写代码测试阶段. 不要加try…except… 要不然. 出错了. 你都不知道. 啥错了, 错哪儿了.","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://xiaochuanfu.github.io/tags/python/"}]},{"title":"html","slug":"html","date":"2022-11-05T13:48:03.000Z","updated":"2022-11-05T13:49:18.238Z","comments":true,"path":"2022/11/05/html/","link":"","permalink":"https://xiaochuanfu.github.io/2022/11/05/html/","excerpt":"","text":"HTML(HyperText Markup Language)前言软件架构 B&#x2F;S Browser/Server 网站 C&#x2F;S Client/Server QQ HTML的简介、发展史： 万维网联盟（W3C）维护。包含HTML内容的文件最常用的扩展名是.html，但是像DOS这样的旧操作系统限制扩展名为最多3个字符，所以.htm扩展名也被使用。虽然现在使用的比较少一些了，但是.htm扩展名仍旧普遍被支持。 相关历程： 超文本标记语言(第一版) – 在1993年6月发为互联网工程工作小组(IETF)工作草案发布(并非标准) HTML 2.0 – 1995年11月作为RFC 1866发布,在RFC 2854于2000年6月发布之后被宣布已经过时 HTML 3.2 – 1996年1月14日,W3C推荐标准 HTML 4.0 – 1997年12月18日,W3C推荐标准 HTML 4.01(微小改进) – 1999年12月24日,W3C推荐标准 ISO&#x2F;IEC 15445:2000(“ISO HTML”)–2000年5月15日发布,基于严格的HTML4.01语法,是国际标准化组织和国际电工委员会的标准 XHTML 1.0 – 发布于2000年1月26日,是W3C推荐标准,后来经过修订于2002年8月1日重新发布 XHTML 1.1 – 于2001年5月31日发布 XHTML 2.0 XHTML 1.0 – 发布于2000年1月26日,是W3C推荐标准,后来经过修订于2002年8月1日重新发布 XHTML – W3C工作草案 网站： 把所有的网站资源文件（HTML,CSS,JS,图片,视频等）整合到一起(的一个文件夹) 编程语言：解释型和编译型 解释型：HTML、PHP、Javascript，Python 编译型语言：C、C++、Java WEB前端：HTML+CSS+JavaScript HTML：结构标准，超文本标记语言，负责通过标签来表达网页的页面结构。 css：外观标准，层叠样式表标记语言，负责通过属性标记来表达网页的外观效果。 javascript: 行为标准，js，负责通过编程代码来表达网页的行为特效。 HTML5: HTML5+CSS3+Api+JavaScript+框架 一、什么是HTML？超文本标记语言 (1) 标签 也叫做 标记+ (2) html是由标签/标记 和内容组成的 (3) 标签 是由 标签名称 和属性组成的 实例： &lt;人 肤色&#x3D;“黄色” 眼镜&#x3D;”很大”&gt;&lt;&#x2F;人&gt; 扩展： 使用协议为 http超文本传输协议 普通文本：文字内容 超文本：视频、音频、图片、文字… 二、HTML的主体标签实例 1234567891011&lt;!DOCTYPE html&gt; #H5的头 声明文档类型 为html&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;http://www.w3.org/TR/xhtml1/TDT/xhtml1-strit.dtd&quot;&gt; #之前的头文件 现在不用&lt;html&gt;&lt;head&gt; &lt;title&gt;标题内容&lt;/title&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; #设置字符集&lt;/head&gt;&lt;body&gt; 放html的主体标签&lt;/body&gt;&lt;/html&gt; html:文件是网页，浏览器加载网页，就可以浏览 head:头部分，网页总体信息 title:网页标题 meta：网页主体信息，会根据name(author&#x2F;description&#x2F;keywords) link:引入外部文件和C#中的using异曲同工 style：写入CSS script：写入JS body:身体部分，网页内容 三、HTML的标签标签分为：单标签&#x2F;单标记 如：&lt;br &#x2F;&gt; &#x2F;&lt;br &gt; 双标签&#x2F;双标记 如: &lt;p&gt;&lt;&#x2F;p&gt; 1、 文本标签 &lt;div&gt;&lt;/div&gt; 块标签 作用是设定字、画、表格等的摆放位置 &lt;p&gt;&lt;/p&gt; 段落标签 自成一段 会将上下的文字 和它保持一定的距离 &lt;h1&gt;-&lt;/h6&gt; 标题标签 字体加粗 自占一行 注意： 建议一个页面h1只能出现一次 2、 图片标签&lt;img /&gt; 在网页中插入一张图片 属性： src： 图片名及url地址 (必须属性) alt: 图片加载失败时的提示信息 title：文字提示属性 width：图片宽度 height：图片高度 实例: 1&lt;img src=&quot;图片地址&quot; title=&quot;文字提示&quot; alt=&quot;图片加载失败显示得信息&quot; width=&quot;宽&quot; height=&quot;高&quot; border=&quot;边框&quot; /&gt; 注意： 如果宽和高 只给一个 那么为等比缩放 如果俩个都给 那么会按照 你所给的宽和高来显示 3、路径 相对路径 .&#x2F; 当前 ..&#x2F; 上一级 绝对路径 一个固定得链接地址(如域名) 从根磁盘 一直到你的文件得路径 file协议 打开本地磁盘文件得协议（试一下火狐） 4、 超链接&lt;a href&#x3D;”链接地址” title&#x3D;”提示信息” target&#x3D;”打开方式” rel&#x3D;”noopener”&gt;点击显示得内容&lt;&#x2F;a&gt; 属性： href必须，指的是链接跳转地址 target: _blank 新建窗口得形式来打开 _self 本窗口来打开(默认) title：文字提示属性（详情） 5、 列表 无序列表*12345678910&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt;&lt;!--属性： type 显示得类型 square 方形显示 disc 默认圆点 circle 空心圆--&gt; 有序列表12345678&lt;ol&gt; &lt;li&gt;&lt;/li&gt;&lt;/ol&gt;&lt;!--属性 type i a A 1 start 起始值--&gt; 自定义列表1234&lt;dl&gt; &lt;dt&gt;列表头&lt;/dt&gt; &lt;dd&gt;列表内容&lt;/dd&gt;&lt;/dl&gt; 6、 HTML注释多行注释： 注释的作用： 代码的调试 解释说明 四、分帧frameset 1、定义和用法frameset 元素可定义一个框架集。它被用来组织多个窗口（框架）。每个框架存有独立的文档。在其最简单的应用中，frameset 元素仅仅会规定在框架集中存在多少列或多少行。您必须使用 cols 或 rows 属性。 2、可选的属性 属性 值 描述 cols pixels % * 定义框架集中列的数目和尺寸 rows pixels % * 定义框架集中行的数目和尺寸 frameborder 1&#x2F;0 是否显示边框 name 给当前分帧窗口起名称 src 连接的页面名称 noresize noresize 页面不会被拖拽 实例 12345678&lt;frameset rows=&quot;20%,*,20%&quot; frameborder=&quot;1/0&quot;&gt; &lt;frame src=&quot;&quot; name=&quot;分帧名1&quot;&gt; &lt;frameset cols=&quot;20%,*&quot; frameborder=&quot;1/0&quot;&gt; &lt;frame src=&quot;&quot; name=&quot;分帧名1&quot;&gt; &lt;frame src=&quot;&quot; name=&quot;分帧名2&quot;&gt; &lt;/frameset&gt; &lt;frame src=&quot;&quot; name=&quot;分帧名3&quot;&gt;&lt;/frameset&gt; 注意： 不可以和body在一起 需要将body删掉 五 TABLE表格table表格 1、属性： width 宽 height 高 border 边框 align位置 center&#x2F;left&#x2F;right valign规定单元格内容的垂直排列方式。 top 对内容进行上对齐。 middle 对内容进行居中对齐（默认值）。 bottom 对内容进行下对齐。 baseline 与基线对齐。 rowspan合并行 colspan合并列 2、标签：caption 表格标题 *tr 行标签 *th 列头标签*td 列标签 实例： 12345678910111213&lt;table&gt; &lt;caption&gt;我是表格的标题&lt;/caption&gt; &lt;tr&gt; &lt;th&gt;我是表头&lt;/th&gt; &lt;th&gt;我是表头&lt;/th&gt; &lt;th&gt;我是表头&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;我是单元格&lt;/td&gt; &lt;td&gt;我是单元格&lt;/td&gt; &lt;td&gt;我是单元格&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 六 FORM表单标签： &lt;form&gt;&lt;/form&gt; 1、 form属性1234567891011action 提交的地址method 提交的方式 get (1) 默认不写 为get传参 url地址栏可见 (2) 长度受限制 （IE浏览器2k火狐8k） (3) 相对不安全 post (1) url地址栏不可见 长度默认不受限制 (2) 相对安全enctype 提交的类型 enctype属性 在表单有文件上传的时候 需要设置值 值为multipart/form-data 2、input 标签&lt;input&gt; 表单项标签input定义输入字段，用户可在其中输入数据。在 HTML 5 中，type 属性有很多新的值。 具体在下面有详解： 如： &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; 3、 select 标签创建下拉列表。属性： *name属性:定义名称,用于存储下拉值的 disabled 当该属性为 true 时，会禁用该菜单。 内嵌标签：*&lt;option&gt; 下拉选择项标签,用于嵌入到&lt;select&gt;标签中使用的; 属性： *value属性:下拉项的值 *selected属性:默认下拉指定项. 4、 *textarea 多行的文本输入区域属性： * name :定义名称,用于存储文本区域中的值。 *cols ：规定文本区内可见的列数。 *rows ：规定文本区内可见的行数。 5、input 标签搭配label标签使用 label 可以使标签内的区域指向label标签for属性指代的对象的事件。 实例： 12&lt;label for=&quot;male&quot;&gt;Male&lt;/label&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;male&quot; /&gt; *type属性:表示表单项的类型: 值如下: text:单行文本框 password:密码输入框 checkbox:多选框 注意要提供value值 radio:单选框 注意要提供value值 file:文件上传选择框 button:普通按钮 submit:提交按钮 reset:重置按钮, 还原到开始(第一次打开时)的效果 hidden:表单隐藏域,是要和表单一块提交的信息,但是不需要用户修改 七、HTML中HEAD头部设置(了解)设置网页编码： &lt;meta charset=&quot;utf-8&quot;/&gt; 自动刷新： &lt;meta http-equiv=&quot;refresh&quot; content=&quot;时间;url=网址&quot; /&gt; 关键字： &lt;meta name=&quot;Keywords&quot; content=&quot;关键字&quot; /&gt; 描述： &lt;meta name=&quot;Description&quot; content=&quot;简介、描述&quot; /&gt; 站点作者: &lt;meta name=&quot;author&quot; content=&quot;root,root@xxxx.com&quot;&gt;告诉搜索引擎你的站点的制作的作者； 网页标题： &lt;title&gt;本网页标题&lt;/title&gt; 导入CSS文件： &lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;**.css&quot;/&gt; CSS代码： &lt;style type=&quot;text/css&quot;&gt;嵌入css样式代码&lt;/style&gt; JS文件或代码： &lt;script &gt;。。。&lt;/script&gt; 设置网页小图标: &lt;link rel=&quot;icon&quot; href=&quot;/favicon.ico&quot; type=&quot;image/x-icon&quot; /&gt; 注意： 头标签中的内容不会显示在浏览器中","categories":[],"tags":[{"name":"html","slug":"html","permalink":"https://xiaochuanfu.github.io/tags/html/"}]},{"title":"Linux","slug":"Linux基础","date":"2022-11-05T13:33:32.000Z","updated":"2022-11-05T13:55:35.771Z","comments":true,"path":"2022/11/05/Linux基础/","link":"","permalink":"https://xiaochuanfu.github.io/2022/11/05/Linux%E5%9F%BA%E7%A1%80/","excerpt":"","text":"一、linux目录 二、Linux学习路线 三、Vim使用 四、初识Linux 2.1. 文件相关 chmod更改文件权限 基本用法： chmod [选项] 模式 文件 模式对应相应的权限，可以是数字法，也可以是文字法 一个文件对应拥有三种角色的权限设定： 拥有者 所属组 其他 数字法和文字法 数字法：r : 4 可读，w : 2 可写，x : 1 可执行 r-x：5，rw-：6，rwx：7 文字法： u：拥有者，g：所属组，o：其他，a：全部 +：增加，-：减去，&#x3D;：设定 eg： u+w 给拥有者增加‘w’权限 ugo-x 给拥有者、所属用户、其他用户减去’可执行’权限 ls：查看文件信息 -l -al cd：进入文件夹 .：当前目录 ..：上一级目录 cp：复制文件 rm：删除文件 mv：移动文件，重命名文件 touch：创建一个空文件，路径为当前路径 搜索文件： whereis which：在$PATH环境变量中指定的路径来搜索可执行文件所在的位置，一般用来确认系统是否安装了指定的软件 type：type命令是用来判断一个命令是否属于shell内置的 find：非常强大的命令，效率差，整个文件下查找 压缩解压文件： 解压缩 tar -vx -f filename tar -vxf filename 压缩：相比解压缩多一个命令选项，即采用的压缩算法，z代表gz，j代表bz2，J代表xz tar -zcvf filename.tar.gz FILES或 tar -jcvf filename.tar.bz2 FILES tar -Jcvf filename.tar.xz FILES 2.2. 程序执行相关 Linux多任务协调机制 管道 匿名管道 命名管道 I&#x2F;O重定向 显式重定向 隐式重定向 管道 概念：管道是Linux系统提供的多任务协调机制的一种，可分为匿名管道和命名管道 匿名管道的创建采用| 命名管道的创建使用mkfifo ，文件类型是p I&#x2F;O重定向 显式重定向 &gt; &lt; 隐式重定向 如匿名管道的使用 多任务 创建一个后台任务，直接在命令行末尾添加&amp;来完成 查看后台任务，采用命令jobs 切换前台任务至后台，采用命令bg 切换后台任务至前台，采用命令fg 关闭任务 前台任务：Ctrl+C 后台任务：kill -num %pid 关闭当前终端，前后台任务均会被干掉 将任务脱离终端，采用命令nohup nohup [命令参数] &amp; 计划任务执行： 一次性任务：at 周期性任务：cron，利用cron表，使用crontab命令来安排周期性任务 corntab -e 打开编辑cron表 crontab -l查看当前用户的cron表 corntab -r删除当前用户的cron进程 corntab -u 用户名以某用户的身份来控制cron表 一个cron任务的完整定义为： 分钟 小时 日 月 周 [用户名] 命令 符号 含义 | * | 代表任意时间 | | ， | 代表分隔出不连续的时间点，比如2,3表示2,3都行 | | - | 代表连续的时间段，比如2-4，表示2、3、4 | | */n | 表示每隔单位时间 | 了解程序信息 ps：查看程序的静态信息，即某个时间的程序运行状况撷取下来 ps aux查看系统中所有程序的数据 ps ux查看当前用户所有程序的数据 ps -l查看与当前终端关联的程序数据 top：动态监测系统中程序的运行状态 top -d更改top刷新频率，默认5s刷新一次 top -p PID单独追踪某个进程的运行状态 pstree：查看进程的父子祖先关系 shell相关 相关环境 进程的权限 工作目录 文件创建掩码 特殊变量 局部变量 环境变量（可以采用set、env、export设置环境变量，使用unset清除设置） PATH HOME LOGNAME IFS SHELL 打开的文件和信号 配置相关 系统层的函数、别名和环境等设置一般在/etc/profile 用户层的相关配置在~/.bash_profile、 ~/.bash_login 和 ~/.profile中，主要是~/.bash_profile，如果./bashrc文件存在，~/.bash_profile还会调用 2.3. 软件安装 从源代码安装软件 configure：检查待安装源码的Linux系统的相关软件属性，创建Makefile文件 make：根据Makefile的指示开展编译工作，理由gcc将原始代码编译成目标文件，这些目标文件通过函数库链接产生完整的可执行文件 make install：make根据Makefile这个文件里面关于install的项目，将上一个步骤所编译完成的文件安装到预定的目录中 利用软件管理工具安装 提供了软件包的安装、更新、和卸载 rpm：Red Hat包管理器 安装：rpm -ivh &lt;rpm 软件包名&gt; 查询：rpm -qa xxx*，rpm -ql &lt;rpm 包名&gt; 卸载：rpm -e&lt;rpm 软件名&gt; dpkg：Debian软件包管理器 安装：dpkg -i &lt;deb 软件包名&gt; 查询： dpkg -l xxx*通配符模式进行模糊查询，xxx指软件名称开头的几个字母 dpkg --listfiles xxx查询系统中属于xxx软件的文件 卸载：dpkg -e &lt;deb 软件名&gt; 线上升级&#x2F;安装 项目 yum apt-get 简介 Red Hat 版本使用 Debian 版本使用 安装 yum install &lt;package_name&gt; apt-get install &lt;package_name&gt; 升级 yum update &lt;package_name&gt; 刷新软件源，建立更新软件包列表apt-get update将系统中的所有软件包一次性升级到最新的版本apt-get upgrade 卸载 yum remove &lt;package_name&gt; apt-get remove &lt;package_name&gt;清除软件包同时清除配置apt-get purge remove &lt;package_name&gt; 查询 1. 查询软件包：yum search &lt;keyword&gt; 2. 列出所有已安装的软件包：yum list installed3. 获取包信息：yum info &lt;package_name&gt;4. 列出软件包提供哪些文件：yum provides &lt;package_name&gt; 1. 查找软件包：apt-cache search &lt;keyword&gt; or &lt;regular expression&gt;2. 获取指定软件包的详细信息：apt-cache show &lt;package_name&gt;3. 获取软件包版本和软件包的依赖关系：apt-cache showpkg &lt;package_name 清楚缓存 下载的软件包和 header 存储在 cache 中不会自动删除。使用yum clean完成清除磁盘空间的操作：1. 清除 header:yum clean headers2. 清除下载的rpm包:yum clean packages3. 清除缓存的软件包及旧 headers:yum clean all 1. 清理整个软件包缓冲区：apt-get clean2. 按照依赖关系清理缓冲区中多余的软件包：apt-get autoclean 2.4. 磁盘的管理方式2.4.1 文件系统Linux采用设备文件来描述一个设备。 交换分区（swap）同Windows的页面文件是相同的概念，就是虚拟内存管理是要使用的内存置换文件，就是用来扩展虚拟内存空间的 Linux采用的文件系统为**ExtN (N&#x3D;2,3,4)**，是一种索引式文件系统，包含inode数据结构代表一个文件，并存储这个文件的各种属性和权限，实际数据存放在data block块区中，此外还包括一个超级块区superblock，用于记录整个文件系统的整体信息。ExtN文件系统可以通过inode一次性获得文件数据存放的位置，并据此安排磁盘的阅读顺序，尽量保证磁盘在旋转一周的情况下将所有内容读取出来。 Window采用的文件系统是FAT32&#x2F;NTFS，FAT32是一种链式文件系统，也包含data block来存储实际数据，但是FAT32只有将对应的data block读入之后，才知道下一个data block的位置，如果一个文件的data block比较分散的话，很难保证在磁盘只旋转一圈的情况下读取全部数据，有时候甚至要旋转很多圈才能读完数据，这就是所谓的“磁盘碎片”问题。 2.4.2 磁盘的基本操作磁盘是文件的载体，磁盘的基本操作包含df，du，dd，fsck，mount。 df：查看系统中所有磁盘的整体使用量，是总体的磁盘使用量，采用读取磁盘的superblock实现 du：查看局部使用量，它搜索所有的inode来计算局部数据，效率较差 dd：可以读写磁盘的每一个扇区，或者镜像整个磁盘 命令格式为：dd if=input_file of=out_file fsck：对文件系统的损坏进行修复 fsck -t 文件系统 设备名 mount：用于将某些设备上找到的文件系统附加到大文件树上 标准格式：mount [-t 文件系统] 设备名称 挂载点 eg： 将系统的第二块串口硬盘的第一个分区挂接到&#x2F;data目录下，mount /dev/sdb1 /data，或 mount -t vfat /dev/sdb1 /data 将下载到的*.iso文件也可以使用同样的方法挂接到某个目录上直接访问：mount -o loop ./CentOS-6.4-x86_64-bin-DVD1.iso /mnt/centos umount：卸载挂载点 umount /data fdisk：磁盘分区 mkfs：格式化命令 2.4.3 &#x2F;etc&#x2F;fstab 文件 作用决定磁盘各个分区挂接的目录 交换分区： 创建：fdisk 格式化：mkswap 挂接：swapon 关闭：swapoff 2.4.4 弹性调整容量——逻辑卷 概念：就是在磁盘分区和文件系统之间增加一个逻辑层，使得完成弹性调整文件系统的容量。Linux中实现逻辑卷功能的是LVM(Logical Volume Manager，逻辑卷管理器)，CentOS是默认支持的 LVM内容： PV，物理卷，是LVM的基本存储单元，包含与LVM相关的管理参数 VG，卷组，类似于非LVM的物理硬盘，由多个物理卷组成，可以在卷组上创建一个或者多个LVM分区 PE，物理扩展区，由每一个物理卷划分而成的，是LVM的最小存储区，与物理磁盘的”扇区“的基本概念相同。 LVM的默认PE大小是4M，每个卷组最多能含65534个PE，所以一个卷组最大的容量是4M*65534&#x3D;256G，如果改变PE的大小，就能改变卷组的最大容量。 LV，逻辑卷，在卷组之上再进行切分，与在物理磁盘上继续划分分区是一个道理，但是逻辑卷大小必须是PE的整数倍。 LVM的构成图： 到了具体的逻辑卷上，就可以应用mkfs命令进行格式化了，如此一来就能够使用mount命令挂载到系统中了。 基本操作 创建物理卷 创建卷组VG 创建逻辑卷LV 2.5 Linux 上网问题2.5.1 背景知识：子网掩码，在ipv4中，子网掩码是一个四字节数，其中网络部分都为1，主机部分都为0 123456789 //eg:255.255.255.0 这个掩码 11111111.11111111.11111111.00000000 |---------网络部分----------|-主机部分-|/** * 这个掩码中，一个子网最多只能拥有254个主机，0被用来最为网络地址 * 255 被用来作广播地址 * 实际使用是，上诉写法国语繁琐，采用“/网络位数“方法表示 * 如：192.168.1.1/24，24表示子网掩码的前24位都是1 */ 子网掩码(255.255.255.0)与主机地址的IP地址(A.B.C.D)进行按位与运算，就会得到A.B.C.0这样的值，这就表明A.B.C是网络地址，而最后那个被与掉的就是主机地址。 ipv4是32位地址，ipv6是128位地址 2.5.2 相关配置网络的配置文件在/etc/network/interfaces中 直接连接上网： 添加默认网关地址：rote add default gw &lt;运营商的网关地址&gt; 重启网络的命令：sudo /etc/init.d/networking restart 拨号上网： 安装rp-PPPoE软件包 执行pppoe-setup 2.6 正则表达式 信条：要熟练使用Linux，离不开正则表达式 文本：指字符串的集合，其中的字符来自于一个有限的字符集合。 2.6.1 定义就是用来描述任意文本的一种特殊表达式。 2.6.2 含义 两个基本要素 表达式ε表示一个文本，仅包含一个长度位0的字符串，可以理解为{NULL}。通常NULL记作ε 对字符集中的任意字符a，表达式a表示仅有一个字符a的文本，即{a} 三个基本运算规则 两个正则表达式的并，记作X|Y，表示的文本是正则表达式X表示的文本与正则表达式Y表示的文本的并集。eg：a|b所得的文本就是{a，b} 两个表达式的连接，记作XY，表示的文本是将X文本中的每一个字符串后面连接上Y文本中的每一个字符串之后，再把所有这种连接的结果组成一种新的文本，比如X&#x3D;a|b，Y&#x3D;c|d，那么XY所表示的文本就是{ac，bc，ad，bd} 一个正则表达式的克林闭包，记作X*，表示分别讲0个、1个、2个….n个X与自己相连，然后再把所有这些求并，也就是说X* = ε|X|XX|XXX|....，比如a*这个正则表达式，表示的就是无穷文本{ε，a，aa，aaa，....} 优先级： 克林闭包 &gt; 连接运算 &gt; 并运算 扩展运算 []表示括号内的字符做并运算，同时括号内支持范围描述符-，如[abcd]=[a-d]=a|b|c|d，注意如果使用‘-’字符的普通意义，需要将其放在方括号的开头或者最后 方括号中以^字符开头，表示在字符集中排除方括号中所有的字符之后，所剩字符的并运算，如[^ab]则表示除了ab以外的所有字符求并 X?表示X|ε，表示X与空字符串之间可选 X+表示XX*，这等于限制X至少要重复1次 2.7 文本搜索2.7.1 定义grep（global search regular expression (RE)and print out the line，全面搜索正则表达式并逐行打印）就是使用正则表达式用来检索文件内容的强大工具。 grep是一个家族，包含grep，egrep，fgrep 2.7.2 工作机制它在一个或者多个文件中搜索字符串模板，字符串模板使用正则表达式来描述，如果模板包含空格，需要使用引号括起来。模板后面的所有字符串被看做文件名，搜索的所有结果被送到标准输出。它还能从标准输入中搜索，所以结合管道使用 2.7.3 支持的正则表达式 元字符 匹配对象 ^ 表示句首。如^abc表示以abc开首的句子 $ 表示句尾。如abc$表示以abc结尾的句子 * 表示前一个字符集出现次数为0或多次。如ab*c表示a与c之间可有0或者多个b存在。 [] 匹配一个指定范围内的字符，如^[0-9]表示以数字开始的行 [^] 匹配一个不在指定范围内的字符，如\\[^(D-F)level]表示匹配不包含D-F的一个字母开头并紧跟level的行 (…) 匹配一个不在指定范围内的字符，如\\&#39;(magic)\\&#39;，magic标记为1 \\&lt; 表示词首。如\\&lt;abc表示以abc开首的词 \\&gt; 表示词尾。如abc\\&gt;表示以abc结尾的词 2.7.4 排序和去重 统计你最常用的十条历史命令及其使用次数： cut -d&#39; &#39; -f1 ~/.bash_history|sort -d | uniq -c|sort -nr|head 2.7.8 文件对比命令 diff","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://xiaochuanfu.github.io/tags/linux/"}]},{"title":"xiao","slug":"css","date":"2022-03-10T06:04:00.000Z","updated":"2022-11-05T13:56:17.551Z","comments":true,"path":"2022/03/10/css/","link":"","permalink":"https://xiaochuanfu.github.io/2022/03/10/css/","excerpt":"","text":"CSS层叠样式表一、css的语法 什么是css？ 层叠样式表 命名规则： 使用字母、数字或下划线和减号构成，不要以数字开头 格式： 选择器{属性:值;属性:值;属性:值;….} 其中选择器也叫选择符 CSS中注释 1/* ... */ 二、在HTML中如何使用css样式（html中嵌入css的方式）1、内联方式（行内样式）就是在HTML的标签中使用style属性来设置css样式 格式： &lt;html标签 style=&quot;属性:值;属性:值;....&quot;&gt;被修饰的内容&lt;/html标签&gt; &lt;p style=&quot;color:blue;font-family:隶书&quot;&gt;在HTML中如何使用css样式&lt;/p&gt; 特点：仅作用于本标签 2、内部方式（内嵌样式）就是在head标签中使用&lt;style type=&quot;text/css&quot;&gt;....&lt;/style&gt;标签来设置css样式 格式： 123&lt;style type=&quot;text/css&quot;&gt; ....css样式代码&lt;/style&gt; 特点：作用于当前整个页面 3、外部导入方式（外部链入） （推荐）就是在head标签中使用&lt;link/&gt;标签导入一个css文件，在作用于本页面，实现css样式设置 格式： 1&lt;link href=&quot;文件名.css&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot;/&gt; 还可以使用import在style标签中导入css文件。 特点：作用于整个网站 三、**css2的选择符：1、html选择符（标签选择器） 就是把html标签作为选择符使用 如 p{….} 网页中所有p标签采用此样式 1h2&#123;....&#125; 网页中所有h2标签采用此样式 2、class类选择符 (使用点.将自定义名（类名）来定义的选择符)（类选择器P）定义： .类名{样式….} 匿名类 其他选择符名.类名{样式….} 使用：&lt;html标签 class=&quot;类名&quot;&gt;...&lt;/html标签&gt; .mc{color:blue;} &#x2F;* 凡是class属性值为mc的都采用此样式 *&#x2F; p .ps{color:green;} &#x2F;只有p标签中class属性值为ps的才采用此样式&#x2F; 注意：类选择符可以在网页中重复使用 3、Id选择符(ID选择器) 定义： #id名{样式…..} 使用：&lt;html标签 id=&quot;id名&quot;&gt;...&lt;/html标签&gt; 注意：id选择符只在网页中使用一次 选择符的优先级：从大到小 [ID选择符]-&gt;[class选择符]-&gt;[html选择符]-&gt;[html属性] 4、关联选择符（包含选择符） 格式： 选择符1 选择符2 选择符3 …{样式….} 例如： table a{….} &#x2F;*table标签里的a标签才采用此样式*&#x2F; h1 p&#123;color:red&#125; /*只有h1标签中的p标签才采用此样式*/ 5、组合选择符（选择符组） 格式： 选择符1,选择符2,选择符3 …{样式….} h3,h4,h5&#123;color:green;&#125; /*h3、h4和h5都采用此样式*/ 6、*通配符（全局选择器） 说明： 通配符的写法是“*”，其含义就是所有元素。 用法： 常用来重置样式 *&#123;padding:0; margin:0;&#125; 7、伪类选(伪元素)择符：格式： 标签名:伪类名{样式….} 1234567a:link &#123;color: #FF0000; text-decoration: none&#125; /* 未访问的链接 */a:visited &#123;color: #00FF00; text-decoration: none&#125; /* 已访问的链接 */a:hover &#123;color: #FF00FF; text-decoration: underline&#125; /* 鼠标在链接上 */a:active &#123;color: #0000FF; text-decoration: underline&#125; /* 激活链接 */ 为了简化代码，可以把伪类选择符中相同的声明提出来放在a选择符中； 例如： a{color:red;} a:hover{color:green;} 表示超链接的三种状态都相同，只有鼠标划过变颜色。 伪类（Pseudo classes）是选择符的螺栓，用来指定一个或者与其相关的选择符的状态 优先级:行内-&gt;css3选择器-&gt;id-&gt;class-&gt;html-&gt;html属性四、 CSS3中的选择器 关系选择器： div&gt;p 选择所有作为div元素的子元素p div+p 选择紧贴在div元素之后p元素 div~p 选择div元素后面的所有兄弟元素p 属性选择器： [attribute]选择具有attribute属性的元素。 [attribute&#x3D;value]选择具有attribute属性且属性值等于value的元素。 结构性伪类选择器： 伪类选择器（简称：伪类）通过冒号来定义，它定义了元素的状态，如点击按下，点击完成等，通过伪类可以为元素的状态修改样式。 :before设置在对象前（依据对象树的逻辑结构）发生的内容。 :after设置在对象后（依据对象树的逻辑结构）发生的内容。 12345678910span:before&#123; content: &#x27;必须存在的属性&#x27;; display: block; border:1px solid red;&#125;span:after&#123; content: &#x27;必须存在的属性&#x27;; display: block; border:1px solid red;&#125; 五、CSS中常用的属性：1、color颜色属性：color 英文单词 1&#123;color:red;&#125; 2、字体属性： fontfont *font-size: 字体大小：20px，60%基于父对象的百分比取值 *font-family： 字体：宋体，Arial *font-weight： 字体加粗 ：bold 3、文本属性：*text-align: 文本的位置：left center right*text-decoration: 字体画线：none无、underline下画线，line-through贯穿线*line-height：行高*color： 字体颜色 5、背景属性：background *background-color: 背景颜色 *background-image: 背景图片","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://xiaochuanfu.github.io/tags/css/"}]},{"title":"正则表达式","slug":"正则","date":"2022-03-10T06:04:00.000Z","updated":"2022-11-05T13:56:54.902Z","comments":true,"path":"2022/03/10/正则/","link":"","permalink":"https://xiaochuanfu.github.io/2022/03/10/%E6%AD%A3%E5%88%99/","excerpt":"","text":"一、正则基础1、为什么使用正则 需求 判断一个字符串是否是手机号 解决 编写一个函数，给函数一个字符串，如果是手机号则返回True，否则返回False 代码 12345678910def isPhone(phone): # 长度为11 # 全部都是数字字符 # 以1开头 passif isPhone(&quot;13812345678&quot;): print(&quot;是手机号&quot;)else: print(&quot;不是手机号&quot;) 注意 如果使用正则会让这个问题变得简单 2、正则与re模块简介概述： 正则表达式，又称规则表达式 正则表达式(regular expression)描述了一种字符串匹配的模式（pattern） 正则匹配是一个 模糊的匹配(不是精确匹配) re：python自1.5版本开始增加了re模块，该模块提供了perl风格的正则表达式模式，re模块是python语言拥有了所有正则表达式的功能 如下四个方法经常使用 match() search() findall() finditer() 二、正则表达式1、匹配单个字符与数字 匹配 说明 . 匹配除换行符以外的任意字符，当flags被设置为re.S时，可以匹配包含换行符以内的所有字符 [] 里面是字符集合，匹配[]里任意一个字符 [0123456789] 匹配任意一个数字字符 [0-9] 匹配任意一个数字字符 [a-z] 匹配任意一个小写英文字母字符 [A-Z] 匹配任意一个大写英文字母字符 [A-Za-z] 匹配任意一个英文字母字符 [A-Za-z0-9] 匹配任意一个数字或英文字母字符 [^lucky] []里的^称为脱字符，表示非，匹配不在[]内的任意一个字符 ^[lucky] 以[]中内的某一个字符作为开头 \\d digital 匹配任意一个数字字符，相当于[0-9] \\D 匹配任意一个非数字字符，相当于[^0-9] \\w word 匹配字母、下划线、数字中的任意一个字符，相当于[0-9A-Za-z_] \\W 匹配非字母、下划线、数字中的任意一个字符，相当于[^0-9A-Za-z_] \\s space 匹配空白符(空格、换页、换行、回车、制表)，相当于[ \\f\\n\\r\\t] \\S 匹配非空白符(空格、换页、换行、回车、制表)，相当于[^ \\f\\n\\r\\t] \\b border 匹配单词边界 \\B 匹配非数字边界 \\n newline 查找换行符 \\f form feed 查找换页符 \\r return 查找回车符 \\t tab 查找制表符 \\v vertical tab 垂直制表符 2、匹配锚字符锚字符:用来判定是否按照规定开始或者结尾 匹配 说明 ^ 行首匹配，和[]里的^不是一个意思 $ 行尾匹配 \\A 匹配字符串的开始，和^的区别是\\A只匹配整个字符串的开头，即使在re.M模式下也不会匹配其他行的行首 \\Z 匹配字符串的结尾，和$的区别是\\Z只匹配整个字符串的结尾，即使在re.M模式下也不会匹配其他行的行尾 3、限定符限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 * 或 + 或 ? 或 {n} 或 {n,} 或 {n,m} 共6种。 匹配 说明 (xyz) 匹配括号内的xyz，作为一个整体去匹配 一个单元 子存储 x? 匹配0个或者1个x，非贪婪匹配 x* 匹配0个或任意多个x x+ 匹配至少一个x x{n} 确定匹配n个x，n是非负数 x{n,} 至少匹配n个x x{n,m} 匹配至少n个最多m个x x|y |表示或的意思，匹配x或y 三、re模块中常用函数通用flags（修正符） 值 说明 re.I 是匹配对大小写不敏感 re.M 多行匹配，影响到^和$ re.S 使.匹配包括换行符在内的所有字符 通用函数 获取匹配结果 使用group()方法 获取到匹配的值 groups() 返回一个包含所有小组字符串的元组(也就是自存储的值)，从 1 到 所含的小组号。 1、match()函数 原型 1def match(pattern, string, flags=0) 功能 匹配成功返回 匹配的对象 匹配失败 返回 None 获取匹配结果 使用group()方法 获取到匹配的值 groups() 返回一个包含所有小组字符串的元组，从 1 到 所含的小组号。 注意：从第一位开始匹配 只匹配一次 参数 参数 说明 pattern 匹配的正则表达式(一种字符串的模式) string 要匹配的字符串 flags 标识位，用于控制正则表达式的匹配方式 代码 1234567891011import reres = re.match(&#x27;\\d&#123;2&#125;&#x27;,&#x27;123&#x27;)print(res.group())print(res.span())#给当前匹配到的结果起别名s = &#x27;3G4HFD567&#x27;re.match(&quot;(?P&lt;value&gt;\\d+)&quot;,s)print(x.group(0))print(x.group(&#x27;value&#x27;)) 2、searce()函数 原型 1def search(pattern, string, flags=0) 功能 扫描整个字符串string，并返回第一个pattern模式成功的匹配 匹配失败 返回 None 参数 参数 说明 pattern 匹配的正则表达式(一种字符串的模式) string 要匹配的字符串 flags 标识位，用于控制正则表达式的匹配方式 注意： 只要字符串包含就可以 只匹配一次 示例 12345import reres = re.search(&#x27;[a-z]&#x27;, &#x27;131A3ab889s&#x27;)print(res)print(res.group() 注意 与search的区别 相同点： 都只匹配一次 不同点： search是在要匹配的字符串中 包含正则表达式的内容就可以 match 必须第一位就开始匹配 否则匹配失败 3、findall()函数（返回列表） 原型 1def findall(pattern, string, flags=0) 功能 扫描整个字符串string，并返回所有匹配的pattern模式结果的字符串列表 参数 参数 说明 pattern 匹配的正则表达式(一种字符串的模式) string 要匹配的字符串 flags 标识位，用于控制正则表达式的匹配方式 示例 12345678910111213141516171819202122232425262728293031myStr = &quot;&quot;&quot;&lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt;&lt;A href=&quot;http://www.taobao.com&quot;&gt;淘宝&lt;/A&gt;&lt;a href=&quot;http://www.id97.com&quot;&gt;电影网站&lt;/a&gt;&lt;i&gt;我是倾斜1&lt;/i&gt;&lt;i&gt;我是倾斜2&lt;/i&gt;&lt;em&gt;我是倾斜2&lt;/em&gt;&quot;&quot;&quot;# html里是不区分大小写# （1）给正则里面匹配的 加上圆括号 会将括号里面的内容进行 单独的返回res = re.findall(&quot;(&lt;a href=\\&quot;http://www\\.(.*?)\\.com\\&quot;&gt;(.*?)&lt;/a&gt;)&quot;,myStr) #[(&#x27;&lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt;&#x27;, &#x27;baidu&#x27;, &#x27;百度&#x27;)]# 括号的区别res = re.findall(&quot;&lt;a href=\\&quot;http://www\\..*?\\.com\\&quot;&gt;.*?&lt;/a&gt;&quot;,myStr) #[&#x27;&lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt;&#x27;]#(2) 不区分大小写的匹配res = re.findall(&quot;&lt;a href=\\&quot;http://www\\..*?\\.com\\&quot;&gt;.*?&lt;/a&gt;&quot;,myStr,re.I) #[&#x27;&lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt;&#x27;, &#x27;&lt;A href=&quot;http://www.taobao.com&quot;&gt;淘宝&lt;/A&gt;&#x27;]res = re.findall(&quot;&lt;[aA] href=\\&quot;http://www\\..*?\\.com\\&quot;&gt;.*?&lt;/[aA]&gt;&quot;,myStr) #[&#x27;&lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt;&#x27;]#(3) 使.支持换行匹配res = re.findall(&quot;&lt;a href=\\&quot;http://www\\..*?\\.com\\&quot;&gt;.*?&lt;/a&gt;&quot;,myStr,re.S) ##(4) 支持换行 支持不区分大小写匹配res = re.findall(&quot;&lt;a href=\\&quot;http://www\\..*?\\.com\\&quot;&gt;.*?&lt;/a&gt;&quot;,myStr,re.S|re.I) #print(res) 贪婪与非贪婪模式 Chapter 1 - 介绍正则表达式 贪婪：下面的表达式匹配从开始小于符号 (&lt;) 到关闭 H1 标记的大于符号 (&gt;) 之间的所有内容。 1/&lt;.*&gt;/ 非贪婪：如果您只需要匹配开始和结束 H1 标签，下面的非贪婪表达式只匹配 。 1/&lt;.*?&gt;/ 如果只想匹配开始的 H1 标签，表达式则是： 1/&lt;\\w+?&gt; 4、finditer()函数 原型 1def finditer(pattern, string, flags=0) 功能 与findall()类似，返回一个迭代器 参数 参数 说明 pattern 匹配的正则表达式(一种字符串的模式) string 要匹配的字符串 flags 标识位，用于控制正则表达式的匹配方式 代码 12345678import reres = re.finditer(&#x27;\\w&#x27;, &#x27;12hsakda1&#x27;)print(res)print(next(res))for i in res: print(i) 5、split()函数 作用：切割字符串 原型： 1def split(patter, string, maxsplit=0, flags=0) 参数 pattern 正则表达式 string 要拆分的字符串 maxsplit 最大拆分次数 默认拆分全部 flags 修正符 示例 12345import remyStr = &quot;asdas\\rd&amp;a\\ts12d\\n*a3sd@a_1sd&quot;#通过特殊字符 对其进行拆分 成列表res = re.split(&quot;[^a-z]&quot;,myStr)res = re.split(&quot;\\W&quot;,myStr) 6、修正符 作用 对正则进行修正 使用 search&#x2F;match&#x2F;findall&#x2F;sub&#x2F;subn&#x2F;finditer 等函数 flags参数的使用 修正符 re.I 不区分大小写匹配 re.M 多行匹配 影响到^ 和 $ 的功能 re.S 使.可以匹配换行符 匹配任意字符 使用 re.I 12print(re.findall(&#x27;[a-z]&#x27;,&#x27;AaBb&#x27;))print(re.findall(&#x27;[a-z]&#x27;,&#x27;AaBb&#x27;, flags=re.I)) re.M(实际) 12345678910myStr = &quot;&quot;&quot;asadasdd1\\nbsadasdd2\\ncsadasdd3&quot;&quot;&quot;print(re.findall(&#x27;^[a-z]&#x27;,myStr, ))print(re.findall(&#x27;\\A[a-z]&#x27;,myStr))print(re.findall(&#x27;\\d$&#x27;,myStr))print(re.findall(&#x27;\\d\\Z&#x27;,myStr))# re.Mprint(re.findall(&#x27;^[a-z]&#x27;,myStr, flags=re.M))print(re.findall(&#x27;\\A[a-z]&#x27;,myStr, flags=re.M))print(re.findall(&#x27;\\d$&#x27;,myStr, flags=re.M))print(re.findall(&#x27;\\d\\Z&#x27;,myStr, flags=re.M)) re.S 12print(re.findall(&#x27;&lt;b&gt;.*?&lt;/b&gt;&#x27;,&#x27;&lt;b&gt;b标签&lt;/b&gt;&#x27;))print(re.findall(&#x27;&lt;b&gt;.*?&lt;/b&gt;&#x27;,&#x27;&lt;b&gt;b标\\n签&lt;/b&gt;&#x27;, flags=re.S)) 四、正则高级1、分组&amp;起名称 概念 处理简单的判断是否匹配之外，正则表达式还有提取子串的功能，用()表示的就是要提取的分组 代码 12345#给当前匹配到的结果起别名s = &#x27;3G4HFD567&#x27;re.match(&quot;(?P&lt;value&gt;\\d+)&quot;,s)print(x.group(0))print(x.group(&#x27;value&#x27;)) 说明 正则表达式中定义了组，就可以在Match对象上用group()方法提取出子串来 group(0)永远是原始字符串，group(1)、group(2)……表示第1、2、……个子串 2、编译 概念 当在python中使用正则表达式时，re模块会做两件事，一件是编译正则表达式，如果表达式的字符串本身不合法，会报错。另一件是用编译好的正则表达式提取匹配字符串 编译优点 如果一个正则表达式要使用几千遍，每一次都会编译，出于效率的考虑进行正则表达式的编译，就不需要每次都编译了，节省了编译的时间，从而提升效率 compile()函数 原型 1def compile(pattern, flags=0) 作用 将pattern模式编译成正则对象 参数 参数 说明 pattern 匹配的正则表达式(一种字符串的模式) flags 标识位，用于控制正则表达式的匹配方式 flags 值 说明 re.I 是匹配对大小写不敏感 re.M 多行匹配，影响到^和$ re.S 使.匹配包括换行符在内的所有字符 返回值 编译好的正则对象 示例 1234import rere_phone = re.compile(r&quot;(0\\d&#123;2,3&#125;-\\d&#123;7,8&#125;)&quot;)print(re_phone, type(re_phone)) 编译后其他方法的使用 原型 1234def match(self, string, pos=0, endpos=-1)def search(self, string, pos=0, endpos=-1)def findall(self, string, pos=0, endpos=-1)def finditer(self, string, pos=0, endpos=-1) 参数 参数 说明 string 待匹配的字符串 pos 从string字符串pos下标开始 endpos 结束下标 示例 123456s1 = &quot;lucky&#x27;s phone is 010-88888888&quot;s2 = &quot;kaige&#x27;s phone is 010-99999999&quot;ret1 = re_phone.search(s1)print(ret1, ret1.group(1))ret2 = re_phone.search(s2)print(ret2, ret2.group(1)) 3、贪婪与非贪婪 贪婪模式 贪婪概念：匹配尽可能多的字符 .+ 匹配换行符以外的字符至少一次 .* 匹配换行符以外的字符任意次 实例 12res = re.search(&#x27;&lt;b&gt;.+&lt;/b&gt;&#x27;, &#x27;&lt;b&gt;&lt;/b&gt;&lt;b&gt;b标签&lt;/b&gt;&#x27;)res = re.search(&#x27;&lt;b&gt;.*&lt;/b&gt;&#x27;, &#x27;&lt;b&gt;b标签&lt;/b&gt;&lt;b&gt;b标签&lt;/b&gt;&lt;b&gt;b标签&lt;/b&gt;&lt;b&gt;b标签&lt;/b&gt;&#x27;) 非贪婪模式 非贪婪概念：尽可能少的匹配称为非贪婪匹配，*?、+?即可 .+? 匹配换行符以外的字符至少一次 拒绝贪婪 .*? 匹配换行符以外的字符任意次 拒绝贪婪 实例 12res = re.search(&#x27;&lt;b&gt;.+?&lt;/b&gt;&#x27;, &#x27;&lt;b&gt;b标签&lt;/b&gt;&lt;b&gt;b标签&lt;/b&gt;&#x27;)res = re.search(&#x27;&lt;b&gt;.*?&lt;/b&gt;&#x27;, &#x27;&lt;b&gt;b标签&lt;/b&gt;&lt;b&gt;b标签&lt;/b&gt;&lt;b&gt;b标签&lt;/b&gt;&lt;b&gt;b标签&lt;/b&gt;&#x27;) 五、作业练习一定先把代码写熟练几遍 在写练习！！！！！！！！！ 文件路径-&gt;素材 匹配年.txt 匹配所有正常的年 7年 9年 匹配出 2016&#x2F;06&#x2F;17格式的年月日 匹配邮箱手机号.txt 匹配所有正常的手机号 匹配邮箱 匹配豆瓣 匹配豆瓣图书标题 匹配图书的img标签 并将匹配到的标签写入img.html中 抓取简介 股票.html 匹配出股票信息 匹配大学排名 匹配ranking字段 世界排名 大学名称","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://xiaochuanfu.github.io/tags/python/"}]}],"categories":[],"tags":[{"name":"图床","slug":"图床","permalink":"https://xiaochuanfu.github.io/tags/%E5%9B%BE%E5%BA%8A/"},{"name":"python","slug":"python","permalink":"https://xiaochuanfu.github.io/tags/python/"},{"name":"html","slug":"html","permalink":"https://xiaochuanfu.github.io/tags/html/"},{"name":"linux","slug":"linux","permalink":"https://xiaochuanfu.github.io/tags/linux/"},{"name":"css","slug":"css","permalink":"https://xiaochuanfu.github.io/tags/css/"}]}